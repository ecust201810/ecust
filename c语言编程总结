https://blog.csdn.net/mengshushu90/article/details/102730730

定义自身类型的成员是不可以的
定义结构体时，是不可以定义自身类型的成员的。这是因为结构体中各个成员所需的存储空间大小是编译阶段确定的，当用该结构体定义自身成员时，由于结构体大小还不确定，因此此时定义的陈冠所需要的存储空间大小也就不确定，因此编译会报错；
定义自身类型的指针成员是可以的
但是可以定义该结构体类型的指针，因为指针在固定的平台上所占的内存大小是确定的！
定义成员函数时，结构体类型做函数参数类型是可以的
函数参数在运行时才会压栈，因此编译是没有问题的；运行时，结构体类型已经是定义好的，因此也不会有问题。
定义成员函数时，结构体指针做函数参数类型是可以的
指针做函数参数，没有问题；


typedef struct struct_exp
{
	struct struct_exp Exp1;    //结构体struct_exp还没定义好，编译器不知道该类型所需多大空间，因此会报错
	struct struct_exp * pExp2;	// pExp2是一个指针，OK
	void fun1(struct struct_exp Exp3); /*Exp3是一个结构体变量做函数参数：
										（1）函数参数在运行时才会压栈，因此编译是没有问题的；
										（2）运行时，结构体类型已经是定义好的，因此也不会有问题*/
	void fun2(struct struct_exp * pExp4); //pExp4是一个指针做函数参数，也是OK的
}struct_exp_t；
